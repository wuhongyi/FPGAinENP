.. verilog.rst --- 
.. 
.. Description: 
.. Author: Hongyi Wu(吴鸿毅)
.. Email: wuhongyi@qq.com 
.. Created: 四 1月  2 20:04:04 2020 (+0800)
.. Last-Updated: 四 10月 15 16:53:29 2020 (+0800)
..           By: Hongyi Wu(吴鸿毅)
..     Update #: 13
.. URL: http://wuhongyi.cn 

##################################################
verilog
##################################################

============================================================
程序结构
============================================================

Verilog 的基本设计单元是模块（module）。一个模块是由两部分组成的，一部分描述接口，一部分描述逻辑功能，用来定义怎么由输入到输出的。

Verilog 程序由三部分构成：I/O 端口声明、信号声明、功能描述。


----------------------------------------------------------------------
端口声明
----------------------------------------------------------------------

模块的端口声明了模块的输入输出接口。其格式如下：

.. code:: verilog

   module 模块名(口1, 口2, 口3, ...);

模块的端口表示的是模块的输入和输出口名，也就是说，它与别的模块联系端口的标识。在模块被引用时，在被引用的模块中，有些信号要输入到被引用的模块中，有的信号需要从被引用的模块中取出来。在引用模块时其端口可以用两种方法连接：
- 在引用时，严格按照模块定义的端口顺序来连接，不用标明原模块定义的规定的端口名，例如：模块名(连接端口1信号名,连接端口2信号名,连接端口3信号名,...);
- 在引用时用“.”符号，标明原模块时定义时规定的端口名，例如：模块名(.端口1名(连接信号1名),.端口2名(连接信号2名), ...);。这样表示的好出在于可以用端口名与被引用模块的端口相对应，而不必严格按端口顺序对应，提高了程序的可读性和可移植性。

----------------------------------------------------------------------
模块内容
----------------------------------------------------------------------

模块的内容包括 I/O 说明、内部信号声明和功能定义。

I/O 说明的格式如下：

.. code:: verilog

  // 输入口
  input [信号位宽-1:0] 端口名1;
  input [信号位宽-1:0] 端口名2;
  // ...
  input [信号位宽-1:0] 端口名i;//共有i个输入口    

  // 输出口
  output [信号位宽-1:0] 端口名1;
  output [信号位宽-1:0] 端口名2;
  // ...
  output [信号位宽-1:0] 端口名j;//共有j个输出口    

  // 输入/输出口
  inout [信号位宽-1:0] 端口名1;
  inout [信号位宽-1:0] 端口名2;
  // ...
  inout [信号位宽-1:0] 端口名k;//共有k个双向总线端口


I/O 说明也可以写在端口声明语句中。其格式如下：

.. code:: verilog

   module module_name(input port1, input port2, ..., output port1, output port2, ...);

  
在模块内部用到的与端口有关的 wire 和 reg 类型变量的声明。例如：

.. code:: verilog

   reg [width-1: 0] R变量1, R变量2;
   wire [width-1: 0] W变量1, W变量2;
   // ...

模块中最重要的部分是逻辑功能定义部分。有 3 种方法可在模块中产生逻辑。

- 用“assign”声明语句，如 assgin a = b&c;
    - 这种方法的句法很简单，只需写一个“assgin”，后面再加一个方程式即可。示例中的方程式描述了一个有两个输入的与门
- 用实例原件，如 and #2 ul(q,a,b);      
    - 采用实例元件的方法像在电路图输入方式下调入库元件一样，键入元件的名字和相连的引脚即可。
    - 这表示在设计中用到一个跟与门（and）一样的名为 ul 的与门，其输入端为 a、b，输出端为 q。输出延迟为 2 个单位时间。
    - 要求每个实例元件的名字必须是唯一的，以避免与其它调用与门（and）的实例混淆。
- 用“always”块，如 always@(posedge clk or posedge clr) begin if(clr) q<=0; else if(en) q<= d; end

采用“assgin”语句是描述组合逻辑最常用的方法之一。而“always”块既可用于描述组合逻辑，也可描述时序逻辑。用“always”块的例子生成了一个带有异步清除端的 D 触发器。“always”块可用很多描述手段来表达逻辑，例如上例就用了 if...else 语句来表达逻辑关系。如按一定的风格来编写“always”块，可以通过综合工具把源代码自动综合成用门级结构表示的组合或时序逻辑电路。
  

============================================================
数据类型及其常量和变量
============================================================

verilog 中总共有 19 种数据类型。数据类型是用来表示数字电路硬件中的数据存储和传送元素的。这里介绍 4 种最基本的数据类型，它们是：reg 型、wire 型、integer 型和 parameter 型。

verilog 语言种也有常量和变量之分，它们分别属于 19 种数据类型。下面就最常用的几种进行介绍。

----------------------------------------------------------------------
常量
----------------------------------------------------------------------

在程序运行中，其值不能被改变的量城为常量。下面首先对在 verilog 语言中使用的数字及其表示方式进行介绍。

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
数字
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

**整数**
  
在 verilog 中，整型常量即整常数有以下 4 种进制表示形式：
- 二进制整数（b或B）
- 十进制整数（d或D）
- 十六进制整数（h或H）
- 八进制整数（o或O）

数字表达方式有以下三种：

- <位宽><进制><数字>，这是一种全面的描述方式。
- 在 <进制><数字> 这种描述方式中，数字的位宽采用默认位宽。
- 在 <数字> 这种描述方式中，采用默认进制（十进制）。

在表达式中，位宽指明了数字的精确位数。例如：一个 4 位二进制数的数字的位宽为 4，一个 4 位十六进制数字的位宽为 16（因为每单个十六进制数就要用 4 位二进制数来表示）。

例如：

.. code:: verilog

   8'b10101100 // 位宽位 8 的数的二进制表示，'b 表示二进制
   8'ha2       // 位宽为 8 的数的十六进制表示，'h 表示十六进制

**x和z值**  

在数字电路中，x 代表不定值，z 代表高阻值。一个 x 可以用来定义十六进制数的 4 位二进制数的状态，八进制数的 3 位，二进制数的 1 位。z 的表示方式同 x 类似。z 还有一种表达方式是可以写作“?”。在使用 case 表达式时建议使用这种写法，以提高程序的可读性。

例如：

.. code:: verilog

   4'b10x0  // 位宽为 4 的二进制数从低位数起第 2 位为不定值
   4'b101z  // 位宽为 4 的二进制数从低位数起第 1 位位高阻值
   12'dz    // 位宽为 12 的十进制数，其值为高阻值（第1种表达方式）
   12'd?    // 位宽为 12 的十进制数，其值为高阻值（第2种表达方式）
   8'h4x    // 位宽为 8 的十六进制数，其低 4 位值为不定值


**负数**

一个数字可以被定义为负数，只需在位宽表达式前加一个减号，减号必须写在数字定义表达式的最前面。减号不可以放在位宽和进制之间，也不可以放在进制和具体的数之间。

例如：

.. code:: verilog

   -8'd5   // 这个表达式代表 5 的补数（用八位二进制数表示）
   8'd-5   // 非法格式

**下划线**

下划线可以用来分隔开数的表达以提高程序的可读性。它不可以用在位宽和进制处，只能用在具体的数字之间。

例如：

.. code:: verilog

   16'b1010_1011_1111_1010  // 合法格式
   8'b_0011_1010            // 非法格式 

当常量不说明位数时，默认值是 32 位，每个字母用 8 位的 ASCII 值表示。例如：

.. code:: verilog

   10=32'd10=32'b1010
   1=32'd1=32'b1
   -1=-32'd1=32'hFFFFFFFF
   'BX=32'BX=32'BXXXXXXX...X
   "AB"=16'B01000001_01000010  // 字符串 AB，为十六进制数 16'h4142


  
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
参数（parameter）型
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

在 verilog 中用 parameter 来定义常量，即用 parameter 来定义一个标识符代表一个常量，称为符号常量，即标识符形式的常量，采用标识符代表一个常量可提高程序的可读性和可维护性。parameter 型数据是一种常数型的数据，其说明格式如下：

.. code:: verilog

   parameter 参数名1=表达式, 参数名2=表达式, ..., 参数名n=表达式;
  
parameter 是参数型数据的确认符。确认符后跟着一个用逗号分隔开的赋值语句表。在每一个赋值语句的右边必须是一个常数表达式。也就是说，该表达式只能包含数字或先前已经定义过的参数。例如：

.. code:: verilog

   parameter msb = 7;     // 定义参数 msb 为常量 7 
   parameter e = 25, f = 29;  // 定义两个常数参数
   parameter f = 5.7;     // 声明 r 为一个实型参数
   parameter byte_size = 8, byte_msb=byte_size-1;  // 用常数表达式赋值 
   parameter average_delay = (r+f)/2;  // 用常数表达式赋值

参数型常量经常用于定义延迟时间和变量宽度。在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数。

   
----------------------------------------------------------------------
变量
----------------------------------------------------------------------

变量是一种在程序运行过程中可以改变的量，在 verilog 中变量的数据类型有多种，这里介绍几种常用的。

网络数据类型表示结构实体之间的物理连接。网络类型的变量不能储存值，而且它必须受到驱动器（例如门或连续赋值语句，assign）的驱动。如果没有驱动器连接到网络类型的变量上，则该变量就是高阻值，即其值为 z。


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
wire 型
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

wire 型数据常用来表示用以 assign 关键字指定的组合逻辑信号。verilog 程序模块中输入、输出信号类型默认时自动定义为 wire 型。wire 型信号可以用做任何方程式的输入，也可以用做“assign”语句或实例元件的输出。


wire 型信号的格式同 reg 型信号的格式很类似。其格式如下：

.. code:: verilog

   wire [n-1:0] 数据名1, 数据名2, ..., 数据名i; // 共有 i 条总线，每条总线内有 n 条线路
   wire [n:1] 数据名1, 数据名2, ..., 数据名i;
   // wire 是 wire 型数据的确认符； [n-1:0] 和 [n:1] 代表该数据的位宽，即该数据有几位；最后跟着的是数据的名字。如果一次定义多个数据，数据名之间之间用逗号隔开。声明语句的最后要用分号表示语句结束。例如：

.. code:: verilog

   wire a;   // 定义了一个 1 位的 wire 型数据
   wire [7:0] b; // 定义了一个 8 位的 wire 型数据
   wire [4:1] c,d; // 定义了二个 4 位的 wire 型数据


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
reg 型
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

寄存器是数据储存单元的抽象。寄存器数据类型的关键字是 reg。通过赋值语句可以改变寄存器储存的值，其作用与改变触发器储存的值相当。verilog 语言提供了功能强大的结构语句，使设计者能有效地控制是否执行这些赋值语句。这些控制结构用来描述硬件触发条件，例如时钟的上升沿和多路器的选通信号。reg 类型数据的默认初始值位不定值 x。

reg 型数据常用来表示“always”模块内的指定，常代表触发器。通常，在设计中要由“always”模块通过使用行为描述语句来表达逻辑关系。在“always”模块内被赋值的每一个信号都必须定义成 reg 型。

reg 型数据的格式如下：

.. code:: verilog

   reg [n-1:0] 数据名1, 数据名2, ..., 数据名i;
   reg [n:1] 数据名1, 数据名2, ...,数据名i;
   // reg 是 reg 型数据的确认标识符；[n-1:0] 和 [n:1] 代表该数据的位宽，即该数据有几位；最后跟着的是数据的名字。如果一次定义多个数据，数据名之间之间用逗号隔开。声明语句的最后要用分号表示语句结束。例如：

.. code:: verilog

   reg rega;   // 定义了一个 1 位的名位 rega 的 reg 型数据
   reg [3:0] regb;  // 定义了一个 4 位的名位 regb 的 reg 型数据
   reg [4:1] regc, regd;  // 定义了二个 4 位的名为 regc 和 regd 的 reg 型数据

对于 reg 型数据，其赋值语句的作用就如同改变一组触发器的存储单元的值。在 verilog 中有许多构造（construct）用来控制何时或是否执行这些赋值语句。这些控制构造可用来描述硬件触发器的各种具体情况，如触发条件时用时间的上升沿，或用来描述判断逻辑的细节，如各种多路选择器。

reg 型数据的默认初始值时不定值。reg 型数据可以赋正值，也可以赋负值。但当一个 reg 型数据时一个表达式中的操作数时，它的值被当作时无符号值，即正值。例如，当一个 4 位的寄存器用做表达式中的操作数时，如果开始寄存器被赋以值 -1，则在表达式中进行运算时，其值被认为是 +15。

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
memory 型
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

verilog 通过对 reg 型变量建立数组来对存储器建模，可以描述 RAM 型存储器、ROM 存储器和 reg 文件。数组中的每一个单元通过一个数组索引进行寻址。在 verilog 语言中没有多维数组存在。menory 型数据是通过扩展 reg 型数据的地址范围来生成的。其格式如下：

.. code:: verilog

   reg [n-1:0] 存储器名[m-1:0];
   reg [n-1:0] 存储器名[m:1];
   // reg[n-1:0] 定义了存储器中每一个存储单元的大小，即该存储单元是一个 n 位的寄存器；存储器名后面的 [m-1:0] 或 [m:1] 则定义了该存储器中有多少个这样的寄存器；最后用分号结束定义语句。

这里通过一个例子来说明：

.. code:: verilog

   reg [7:0] mema [255:0];
   // 定义了一个名为 mema 的存储器，该存储器有 256 个 8 位的存储器。该存储器的地址范围是 0 到 255。


   
============================================================
运算符及表达式
============================================================

verilog 语言的运算符范围很广，其运算符按其功能可分为以下几类：

- 算术运算符（+,-,x,/,%）
- 赋值运算符（=,<=）
- 关系运算符（>,<,>=,<=）
- 逻辑运算符（&&,||,!）
- 条件运算符（?:）
- 位运算符（~,|,^,&,^~）
- 移位运算符（<<,>>）
- 拼接运算符（{ }）
- 其它

----------------------------------------------------------------------
算术运算符
----------------------------------------------------------------------

在 verilog 语言中，算术运算符又称为二进制运算符，共有下面几种：

- + （加法运算符，或正值运算符）
- - （减法运算符，或负值运算符）
- x （乘法运算符）
- / （除法运算符）
- % （模运算符，或称为求余运算符，要求%两侧均为整型数据。）

在进行整数除法运算时，结果值要略去小数部分，只取整数部分；而进行取模运算时，结果值的符号位采用模运算式里第一个操作数的符号位。

  

----------------------------------------------------------------------
位运算符
----------------------------------------------------------------------

verilog 作为一种硬件描述语言，是针对硬件电路而言的。在硬件电路中信号有 4 种状态值，即 1，0，x，z。在电路中信号进行与、或、非时，反映在 verilog 中则是相应的操作数的位运算。verilog 提供了以下 5 种位运算符：

- ~    取反
- &    按位与
- |    按位或
- ^    按位异或
- ^~   按位同或（异或非）

----------------------------------------------------------------------
逻辑运算符
----------------------------------------------------------------------

在 verilog 语言中存在 3 种逻辑运算符：

- &&  逻辑与
- ||  逻辑或
- !   逻辑非

逻辑运算符中“&&”和“||”的优先级别低于关系运算符，“!”高于算术运算符。

为了提高程序的可读性，明确表达各运算符元间的优先关系，建议使用括号。


----------------------------------------------------------------------
关系运算符
----------------------------------------------------------------------

关系运算符共有以下 4 种：

- a<b，读作a小于b
- a>b，读作a大于b
- a<=b，读作a小于或等于b
- a>=b，读作a大于或等于b

在进行关系运算时，如果声明的关系是假的（false），则返回值是0；如果声明的关系是真的（true），则返回值是1；如果某个操作数的值不定，则关系是模糊的，返回值是不定值。

所有的关系运算符有着相同的优先级别。关系运算符的优先级别低于算术运算符的优先级别。


----------------------------------------------------------------------
等式运算符
----------------------------------------------------------------------

在 verilog 语言中存在 4 种等式运算符：

- == （等于）
- !=  （不等于）
- === （等于）
- !== （不等于）

“==”和“!=”又称为逻辑等式运算符，其结果由两个操作数的值决定。由于操作数种某些位可能是不定值 x 和高阻值 z，结果可能为不定值 x。而“===”和“!==” 运算符则不同，它在对操作数进行比较时对某些位的不定值 x 和高阻值 z 也进行比较，两个操作数必须完全一致，其结果才是1，否则为0。“===”和“!==” 运算符常用于 case 表达式的判别，所以又称为“case 等式运算符”。这 4 个等式运算符的优先级别是相同的。

----------------------------------------------------------------------
移位运算符
----------------------------------------------------------------------

在 verilog 种有两种移位运算符：“<<”（左移位运算符）和“>>”（右移位运算符）。其使用方法如下：

.. code:: verilog

   a >> n
   a << n
   // a 代表要进行移位的操作数，n 代表要移几位。这两种移位运算都用0来填补移出的空位。


----------------------------------------------------------------------
位拼接运算符
----------------------------------------------------------------------

在 verilog 语言中有一个特殊的运算符：位拼接运算符。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。其使用方法如下：

.. code:: verilog

   {信号1的某几位, 信号2的某几位, ..., ..., 信号n的某几位}
   // 即把某些信号的某些位详细地列出来，中间用逗号分开，最后用大括号括起来表示一个整体信号。
   // 例如
   {a, b[3:0], w, 3'b101}

在位拼接表达式中不允许存在没有指明位数的信号。这是因为在计算拼接信号位宽的大小时必须知道其中每个信号的位宽。

============================================================
赋值语句和块语句
============================================================

----------------------------------------------------------------------
赋值语句
----------------------------------------------------------------------

在 verilog 中，信号有两种赋值方式：

- 非阻塞赋值方式
    - 在语句块中，上面语句所赋的变量值不能立即就为下面的语句所用
    - 块结束后才能完成这次赋值操作，而所赋值的变量值是上一次赋值得到的
    - 在编写可综合的时序逻辑模块时，这是最常用的赋值方法
- 阻塞赋值方式
    - 赋值语句执行完后，块才结束
      



----------------------------------------------------------------------
块语句
----------------------------------------------------------------------




   
   
.. 
.. verilog.rst ends here
