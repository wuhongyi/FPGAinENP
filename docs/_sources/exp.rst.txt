.. exp.rst --- 
.. 
.. Description: 
.. Author: Hongyi Wu(吴鸿毅)
.. Email: wuhongyi@qq.com 
.. Created: 六 8月 10 22:02:10 2019 (+0800)
.. Last-Updated: 一 6月  7 21:00:42 2021 (+0800)
..           By: Hongyi Wu(吴鸿毅)
..     Update #: 7
.. URL: http://wuhongyi.cn 

##################################################
经验总结
##################################################

============================================================
计数器
============================================================

- 画出输入、输出波形（根据功能要求、画出输入和输出的波形）
- 画出计数器结构
- 确定加1条件（计数器数什么，加1条件不足则加flag_add）
- 确定计数器结束条件（数多少个，个数不同时，用变量法，即用x代替；x不足以区分时则加flag_sel）
- 如果有更新波形
- 其它信号变化点条件（其它信号：即输出或内部信号；变化点：0变1、1变0）
- 写出计数器代码
- 写出其它信号代码



============================================================
状态机
============================================================

- 明确功能
- 输出分析
- 状态合并
- 状态转移条件
- 转移条件
- 完整性检查
- 状态机代码
- 功能代码

============================================================
FIFO
============================================================

- FIFO的写使能写数据，同时用组合逻辑或者同时用时序逻辑。
- FIFO的读使能，用组合逻辑。
- 数据的输出用组合逻辑。

============================================================
波形
============================================================

- 时序逻辑的波形观看方法：时钟上升沿前看输入，时钟上升沿后看输出。
- 组合逻辑的波形观看方法：输入变输出即刻变。


============================================================
抄书
============================================================

**与门**

与门是具有两个或多个输入端和一个输入端的逻辑门。当所有的输入都是逻辑1时，与门输出为逻辑1.换句话说，如果任何输出为0则输出为0。

从原理上说，我们可以定义具有许多输入输入端口的与门，但在具体实现时还是有实际限制的。一般来说与门的输入端最多为4个或5个，如果需要更多的输入端口，那么可以将多个与门级联起来。另外，在实际应用中，通常更倾向于使用与非门，其逻辑功能端进行逻辑与后再取反输出，主要原因是采用CMOS工艺实现的与非门工作速度比与门快得多。

**扇入扇出**
  
逻辑门的扇入指的是一个逻辑门正常工作时输入端的数量，例如，理论上一个与门可以有20个输入端，但是包含20个输入端的与门在工作时可能会因为输入负荷过大而出现逻辑错误或者速度下降的情况，此时扇出就不能选为20。门电路的扇出与具体的电路制造工艺和电路结构有密切关系，进行集成电路设计时，电路单元库中会给出扇入的具体参数。

扇出是在不降低输出电平的情况下逻辑门能够驱动的负载的数量。例如，从理论上讲一个与门可以驱动20个以上的输入端，但此时门电路的输出电容负载非常大，电路的工作速度会严重下降。集成电路单元库中会给出不同类型门电路的扇出。综合工具进行RTL代码综合时，会从单元库中读取扇入和扇出参数，以确保不超过最大值要求。

**通用D触发器**

D触发器有数据、时钟、和 RST# 输入端以及 Q 和 ！Q 两个输出端。在每一个时钟的上升沿，输出 Q 将输入D 的值锁存，直到下一个时钟上升沿出现时才继续锁存当前 D 端的值。！Q 输出的值与 Q 输出的值相反。在时钟上升沿进行输出数据更新时，D 端的输入数据必须满足称为建立时间的定时要求，否则输出端 Q 可能会出现不确定值。

**建立时间**

在时钟上升沿值之前 D 需要保持稳定的最短时间称为建立时间。如果在建立时间内 D 的值发生了变化，那么将无法确定 Q 的电平，其可能为一个不确定的电平值。

**保持时间**

在时钟的上升沿之后的一段时间内，D 的输入值也不允许改变，否则也会造成 Q 输出的不稳定，这个窗口被称为保持时间。

**亚稳态**

当输入 D 在建立时间和保持时间窗口内发生变化时，在此后的几乎一个时钟周期内。输出电平既不是 0 也不是 1，处于不确定值。这种不稳定的状态也被称为亚稳态。亚稳态的输出将在下一个时钟的上升沿之前稳定为 0 或 1。如果亚稳态输出被用于其它逻辑门的输入，那么将会造成难以预计的不良影响，可能会造成连锁反应，使整个数字系统工作不稳定。因此，必须采取一定的设计手段避免 D 触发器进入亚稳态，或者避免亚稳态被传递，影响整个系统的稳定性。

当触发器的输入不满足建立时间和保持时间要求时，输出为亚稳态。为了使系统正常工作，必须采取一定的手段避免或消除其影响。在只有一个时钟的数字系统中（称为单时钟域数字系统），通过控制一个 D 触发器的输出到另一个 D 触发器输入之间组合逻辑门的数量。可以减少其带来的延迟从而避免 D 触发器的输入在建立时间和保持时间窗口内发生波动。但是，当一个数字系统中有两个或两个以上时钟时（称为多时钟域系统），会出现一个时钟域的 D 触发器的输出作为另一个时钟域的 D 触发器输入的情况，当两个时钟之间没有任何关联时，亚稳态的出现时无法避免的。

**信号同步规则**

当信号从一个时钟域进入另一个时钟域时，为了使信号正确传递同时保持系统工作稳定，必须遵循以下几条设计规则。

- 跨时钟域的信号必须直接来自源时钟域的寄存器输出。
   - 如果信号l来自组合逻辑 ，而不时直接来自触发器，可能会造成信号在目标时钟域中出现难以预料的不稳定情况，从而造成整个系统出现无法预测的问题。
- 使用逻辑单元库中的专用触发器实现两级同步器。
   - 这里所说的专用触发器与普通触发器有所不同，它们具有高驱动能力和高增益，这会使它们比常规的触发器更快地进入稳定状态。根据前面的分析，将两个或多个触发器级联起来可以减少亚稳态出现的概率，那么采用这种专用触发器，可以大大提高电路从亚稳态中摆脱出来的速度。
- 在一个点而不是在多个点上进行跨时钟域信号的同步。
   - 同步电路可以消除亚稳态及其传递，但得到的结果可能是 1 也可能是 0，当只有一个连接点时，最多是信号延迟不同的问题，如果是多个点，那么这些信号组合之后的结果可能性非常多，这会造成信号传递的错误，可能会导致下游系统出错。


**事件/边沿检测**

同步上升沿检测

.. code:: verilog
	  
  input sig_a;
  reg sig_a_d1;
  wire sig_a_risedge;
   
  always @(posedge clk or negedge rstb)
    begin
       if(!rstb) sig_a_d1 <= 1'b0;
       else sig_a_d1 <= sig_a;
    end
   
  assign sig_a_risedge = sig_a & !sig_a_d1;


同步下降沿检测

.. code:: verilog

  input sig_a;
  reg sig_a_d1;
  wire sig_a_faledge;
   
  always @(posedge clk or negedge rstb)
    begin
       if(!rstb) sig_a_d1 <= 1'b0;
       else sig_a_d1 <= sig_a;
    end
   
  assign sig_a_faledge = !sig_a & sig_a_d1;
   



同步上升/下降沿检测

.. code:: verilog

  input sig_a;
  reg sig_a_d1;
  wire sig_a_anyedge;
   
  always @(posedge clk or negedge rstb)
    begin
       if(!rstb) sig_a_d1 <= 1'b0;
       else sig_a_d1 <= sig_a;
    end
   
  assign sig_a_anyedge = (!sig_a & sig_a_d1) | (sig_a & !sig_a_d1);


异步输入上升沿检测

.. code:: verilog

   input sig_a;//domain clka
   input clkb;
   input rstb;
   reg 	 sig_a_d1, sig_a_d2, sig_a_d3;
   wire  sig_a_posedge;

   assign sig_a_posedge = sig_a_d2 & !sig_a_d3;

   always @(posedge clkb or negedge rstb)
     begin
	if(!rstb)
	  begin
	     sig_a_d1 <= 1'b0;
	     sig_a_d2 <= 1'b0;
	     sig_a_d3 <= 1'b0;
	  end
	else
	  begin
	     sig_a_d1 <= sig_a;
	     sig_a_d2 <= sig_a_d1;
	     sig_a_d3 <= sig_a_d2;
	  end
     end




     
.. 
.. exp.rst ends here
